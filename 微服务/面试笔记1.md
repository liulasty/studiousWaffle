### 1. **@Resource 和 @Autowired 的区别**

- **@Resource**:
    - 来自 JSR-250 的标准注解，属于 Java EE。
    - 按照 **名称** 优先匹配（`byName`），如果未找到名称匹配，再按照 **类型**（`byType`）匹配。
    - 可以指定 `name` 和 `type` 属性，常用于与传统的 Java EE 环境整合。
- **@Autowired**:
    - Spring 提供的注解。
    - 按照 **类型**（`byType`）优先匹配。
    - 如果需要按名称匹配，可以结合 `@Qualifier` 注解一起使用。
    - 支持 `required` 属性，决定是否必须注入。

---

### 2. **Spring 注入的其他方式**

- **构造器注入**：
    - 使用类的构造方法注入依赖。
    - 推荐用于不可变依赖或强制依赖。
- **Setter 方法注入**：
    - 使用 Setter 方法注入依赖。
    - 常用于可选依赖。
- **接口注入**（较少用）：
    - 通过接口提供依赖的方法。
- **字段注入**：
    - 使用 `@Autowired` 或 `@Resource` 直接注入到字段。

---

### 3. **依赖注入的底层实现方式**

- **反射**：
    - 通过 Java 的反射机制（`Field.set()`、`Constructor.newInstance()`）动态为对象赋值。
- **动态代理**：
    - Spring 使用动态代理处理注入逻辑，特别是在 AOP 和事务管理场景中。

---

### 4. **SpringMVC 接收参数的注解**

- **@RequestParam**：
    - 用于获取请求中的参数，如表单参数或 URL 查询参数。
    - 默认从 `query` 或 `form` 中获取。
- **@PathVariable**：
    - 用于获取 URL 路径中的变量。
    - 例如，`/user/{id}` 中的 `id`。
- **@RequestBody**：
    - 用于接收请求体中的 JSON 数据，并自动反序列化为 Java 对象。
- **@RequestHeader**：
    - 用于获取 HTTP 请求头中的信息。
- **@CookieValue**：
    - 用于获取请求中的 Cookie 数据。

#### 不用注解如何接收参数

- 可以通过 `HttpServletRequest` 手动获取参数：
    
    ```java
    String param = request.getParameter("paramName");
    ```
    

---

### 5. **常用的垃圾回收器**

- **Serial GC**：
    - 单线程，适合单核 CPU 和小内存。
- **Parallel GC**（Throughput Collector）：
    - 多线程，注重吞吐量。
- **CMS GC**（Concurrent Mark-Sweep）：
    - 并发低延迟，适合对响应时间要求高的场景。
- **G1 GC**（Garbage-First）：
    - 分区回收，均衡吞吐量与低延迟。
- **ZGC**：
    - 超低延迟（<10ms），适用于大内存场景。
- **Shenandoah GC**：
    - 类似 ZGC，目标是低延迟。

---

### 6. **Young GC 和 Full GC 的区别**

- **Young GC**：
    - 只清理新生代。
    - 发生频率高，回收时间短。
- **Full GC**：
    - 清理整个堆（新生代 + 老年代）。
    - 发生频率低，但耗时长。

#### 触发 Full GC 的情况

- 老年代内存不足。
- `System.gc()` 被显式调用。
- 永久代（方法区）内存不足。
- GC 调优过程中，CMS 失败或空间碎片无法分配。

---

### 7. **对象进入老年代的条件**

- 默认情况下，**对象年龄达到 15 岁**。
- **动态年龄判定**：若同年龄的对象大小总和大于新生代的 `Survivor` 区的一半，直接进入老年代。
- 大对象（如超大数组）直接进入老年代。

---

### 8. **MySQL 索引**

- **分类**：
    - 主键索引：唯一标识一行记录。
    - 唯一索引：值唯一，但允许 NULL。
    - 普通索引：加速查询，无唯一性限制。
    - 复合索引：多列组合索引。
    - 全文索引：用于全文检索。
- **数据结构**：
    - B+ 树：适用于大多数索引。
    - 哈希索引：仅适用于等值查询。
- **覆盖索引**：
    - 查询的数据直接在索引中可获得，无需回表。

---

### 9. **MySQL 锁机制**

- **表锁**：
    - 适用于全表操作，如 `ALTER TABLE`。
- **行锁**：
    - 适用于 InnoDB 存储引擎，针对具体记录加锁。
- **意向锁**：
    - 表级锁的辅助锁，用于标记当前表中的某些行被锁定。

---

### 10. **Update 语句的锁**

- 默认的 **REPEATABLE READ** 隔离级别下，`UPDATE` 会加 **行锁**。
- 如果更新条件涉及全表扫描，可能会退化为表锁。

---

### 11. **SQL 优化方法**

- 添加索引（主键、唯一索引、覆盖索引）。
- 减少子查询，优化为连接查询。
- 使用 `EXPLAIN` 分析 SQL 执行计划。
- 拆分大表，分库分表。
- 缓存热点数据，减少数据库压力。

#### `EXPLAIN` 中字段含义：

- `id`：查询执行的顺序。
- `select_type`：查询类型（简单查询、子查询等）。
- `table`：涉及的表。
- `type`：连接类型（`ALL`、`index`、`ref`）。
- `key`：使用的索引。
- `rows`：扫描的行数。
- `Extra`：额外信息（`Using index`、`Using where` 等）。

---

### 12. **高重复值索引的行为**

- 当列的重复值较多（如 90% 为同一值），查询可能 **不走索引**。
- 原因：优化器会根据 **成本估算** 判断走全表扫描更高效，因为索引的筛选性（**selectivity**）太低，回表成本较高。